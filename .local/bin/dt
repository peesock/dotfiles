#!/bin/sh

gitDir="$HOME/.dotfiles" # default
workingDir="$HOME"
programName=$(basename "$0")

help(){
	printf %s "\
usage:
$programName [OPTIONS] FUNCTION [ARGS]

options:
-g dir       set git directory to dir (default '$gitDir')
-w dir       set working directory to dir (default '$workingDir')

functions:
init         run git init on git dir
link         recursively hardlink all arguments to git dir (requires GNU cp)
restore      runs link in reverse, restoring your dotfiles from the git repo
add          run link and git add on all arguments
rm           recursively remove *both* existing hardlinks (and folders) of argument
g            runs git with modified options and file paths to change the dot repo
help         helps
dotpath      returns either the git (default) or working (-R) path of specified argument
"
}

while true; do
	[ "$1" = -g ] && {
		gitDir="$2"
		shift 2
		continue
	}
	[ "$1" = -w ] && {
		workingDir="$2"
		shift 2
		continue
	}
	break
done

unset reverse restore

dotpath()(
	[ "$1" = "-R" ] && reverse=true && shift
	[ "$1" = '--' ] && shift
	for file in "$@"; do
		file=$(realpath -m -- "$file") # calling this once for every file sucks but so does shell
		fileWorking=${file#"$workingDir"}
		fileGit=${file#"$gitDir"}

		if [ "$file" != "$fileGit" ]; then
			# we are in the dots folder.
			[ $reverse ] &&
			echo "$workingDir$fileGit" ||
			echo "$gitDir$fileGit"

		elif [ "$file" != "$fileWorking" ] && [ "$file" = "$fileGit" ]; then
			# we are in the home folder.
			[ $reverse ] &&
			echo "$workingDir$fileWorking" ||
			echo "$gitDir$fileWorking"

		else
			echo "error: '$file' above working dir" >&2
			exit=1
			continue
		fi

		exit=0
	done
	return $exit
)

link()(
	[ "$1" = "-R" ] && restore=1 && shift
	[ "$1" = '--' ] && shift
	for infile in "$@"; do
		if [ $restore ]; then
			infile=$(dotpath "$infile")
			outfile=$(dotpath -R -- "$infile")
		else

			outfile=$(dotpath "$infile")
		fi
		mkdir -p "$outfile"
		echo "linking '$infile' to '$outfile'" >&2
		cp -rflT $([ $restore ] && echo '-i') "$infile" "$outfile"
	done
)

rm()(
	for file in "$@"; do
		path=$(dotpath "$file")
		echo "removing '$file' and '$path'" >&2
		/bin/rm -rI "$path" "$file"
	done
)

add()(
	link "$@"
	g add "$@"
)

restore()(
	link -R -- "$@"
)

g(){
	# shellcheck disable=SC2046
	eval 'git --git-dir="$gitDir/.git" --work-tree="$gitDir" '$(
	# if any args are files, ensure they come from $workingDir.
		i=1
		for arg in "$@"; do
			# ensure --option arguments are not seen as files
			[ $files ] || {
				[ "$arg" = "--" ] && files=true && continue
			}
			[ $files ] ||
				echo "$arg" | grep -- '^-\?-[^-]' >/dev/null && {
					i=$((i - 1))
				}
			if [ $files ] || [ -f "$arg" ] && [ $i -gt 1 ]; then
				arg=$(dotpath "$arg") ||
					continue
			fi
			echo "'$arg'"
			i=$((i + 1))
		done
	)''
}

init(){
	mkdir -p "$gitDir"
	git init "$gitDir"
}

if type "$1" | grep -iF "shell function" >/dev/null; then
	"$@"
else
	echo "Run '$programName help' for quick options or see '$0' for all functions."
	exit 1
fi
