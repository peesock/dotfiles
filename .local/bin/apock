#!/bin/sh

# warn feature used with xss-lock
if [ "$1" = "warn" ]; then
	trap 'exit 0' TERM INT
	i=$(xset q | awk '/cycle/{print $4}')
	while [ $i -gt 0 ]; do
		t=2000
		[ $i -eq 1 ] && t=500 # prevents dunst from displaying this when waking up
		notify-send -r 13 -t $t "Locking" "$i\s"
		sleep 1
		i=$((i - 1))
	done
	sleep 2147483647 &
	wait
	elif [ "$1" = "xss" ]; then
		xss=true
		shift
fi

[ "$xss" ] && {
	waitingList=$(pgrep -ax "^$(ps -o comm= $$)" | grep -v " xss\| warn" | awk '{print $1}')
	[ "$waitingList" ] && {
		# ps -o command $waitingList
		# date
		waitpid -e $waitingList
		# echo EXITING
		# date
		exit
	}
	unset waitingList
}

programName=$(basename "$0")

trap 'exit' TERM INT
trap 'kill 0' EXIT

# basic lock command
lock(){
	alock -a passwd "$@"
}

# for storing inaccesible variables
pidDir="/tmp/$USER/$programName"
mkdir -p "$pidDir"/clean

pre(){
	# kill secret services: if someone unlocks my screen, at least they won't have my unencrypted passwords
	passwords -k -K -q 2>/dev/null &

	dunstctl set-paused true
	find "$pidDir" -type f -print0 | xargs -0 rm 2>/dev/null
}
post(){
	dunstctl set-paused false
	kill $(cat "$pidDir/clean"/* 2>/dev/null) 2>/dev/null
	true
}

# simple fallback always runs in case the lock cover fails
fallback(){
	sleep 3
	# external variables used here have to be imported from $pidDIR
	for f in "$pidDir"/* ; do
		[ -f "$f" ] && eval "$(basename "$f")='$(cat "$f")'"
	done
	waitpid $coverPID; (
		notify-send -u critical "Lock screen" "Cover failed. Used fallback" &
		kill $funcPID
		kill $lockPID
		lock
	)
} 2>/dev/null

setfull()(
	until xprop _NET_WM_STATE -id $1 | grep -F "STATE_FULLSCREEN" >/dev/null; do
		xdotool windowstate --add FULLSCREEN $1
	done
)

getwid()(
	unset wid
	until [ "$wid" ]; do
		wid=$(xdotool search --pid $1)
	done
	echo "$wid"
)

# set up visualizer
visualizer()(
	lock -b none & lockPID=$!
	echo $lockPID > "$pidDir/lockPID"

	# pause all non-server programs accessing the fifo
	fifoFile="/tmp/mpd.fifo"
	# pause the shells attached to visualizers (if any) to prevent shitassery
	blackParents=$(chsh -l | while read sh; do basename "$sh"; done)
	# protect these programs accessing the fifo from being paused
	whiteChildren="mpd safe_fifo"

	# create and kill pidList
	for pid in $(lsof "$fifoFile" | sed '1d' | sed 's/\S*\s*//' | cut -d' ' -f1); do
	# for pid in $(sleep 100 | sed '1d' | sed 's/\S*\s*//' | cut -d' ' -f1); do
		pidName="$(ps -cp $pid -o comm="" | sed 's/^\s*//')"
		for n in $whiteChildren; do
			if [ "$n" = "$pidName" ]; then
				protect=true
				break
			else
				protect=false
			fi
		done
		$protect || pidList="$pidList $pid"
		ppid="$(ps -cp $pid -o ppid="" | sed 's/^\s*//')"
		ppidName="$(ps -cp $ppid -o comm="" | sed 's/^\s*//')"
		for n in $blackParents; do
			if [ "$ppidName" = "$n" ]; then 
				pidList="$pidList $ppid"
			fi
		done
	done
	kill -s STOP $pidList 2>/dev/null

	if command -v alacritty >/dev/null; then
		alacritty -o 'colors.primary.background="#000000"' -o 'window.opacity=1' -e vis & coverPID=$!
	else
		xterm -bg '#000000' -e env TERM=xterm-256color vis & coverPID=$!
	fi
	setfull "$(getwid $coverPID)"
	echo $coverPID > "$pidDir/coverPID"

	wait "$lockPID"
	{
		kill "$fallbackPID"
		kill "$coverPID"
		kill -s CONT $pidList 2>/dev/null
	} &
)

xscreensaver()(
	eval 'set -- '$(getopt -o 't:c' -- "$@")
	t=1m
	unset exe
	while true; do
		case "$1" in
			-t)
				t=$2
				shift 2
				;;
			-c)
				cycle=true
				shift
				;;
			--)
				shift
				break
				;;
		esac
	done
	[ "$1" ] && exe=/usr/lib/xscreensaver/$1

	lock -b none & lockPID=$!
	echo $lockPID > "$pidDir/lockPID"

	xterm -bg '#000000' -fg '#000000' -e cat >/dev/null 2>&1 & coverPID=$!
	coverWID=$(getwid $coverPID)
	setfull $coverWID
	xdotool windowactivate $coverWID

	while true; do
		unset exePID
		until [ "$exe" ]; do
			exe=$(find /usr/lib/xscreensaver -maxdepth 1 -type f | grep -v "xscreensaver/xscreensaver\|webcollage\|glitchpeg\|font\|text\|crackberg\|phosphor" | shuf -n1)
			file --mime-type "$exe" | grep -F executable >/dev/null || unset exe # improve
		done
		echo displaying "'$exe'" >&2
		$exe & exePID=$!
		echo $exePID > "$pidDir/clean/exe"
		unset exe
		setfull "$(getwid $exePID)" &
		[ ! "$cycle" ] && wait
		sleep $t
		kill "$exePID"
	done &
	echo $! > "$pidDir/clean/xscreen"
	echo $coverPID > "$pidDir/coverPID"

	wait "$lockPID"
	{
		kill "$fallbackPID" # put this stuff in post maybe
		kill $coverPID
	} &
)

# main
pre
exe=$1
if [ "$exe" ]; then
	shift
	fallback & fallbackPID=$!
	$exe "$@" & echo $! > "$pidDir/funcPID"
	wait
else
	lock
fi
post
