#!/bin/sh

# warn feature used with xss-lock
if [ "$1" = "warn" ]; then
	trap 'exit 0' TERM INT
	i=$(xset q | grep cycle | awk '{print $4}')
	while [ $i -gt 0 ]; do
		t=1050
		[ $i -eq 1 ] && t=600 # prevents dunst from displaying this when waking up
		notify-send -r 13 -t $t "Locking" "$i\s"
		sleep 1
		i=$((i - 1))
	done
	sleep 2147483647 &
	wait
	elif [ "$1" = "xss" ]; then
		xss=true
		shift
fi

programName=$(basename "$0")

if ! [ $xss ] && ps -o command= $(pidof -s "xss-lock") | grep -- "--\s*$programName" >/dev/null; then
	xset s activate
	exit
fi

trap 'kill 0' TERM INT

# lock arguments you'll always want
alias lock='alock -a passwd'

# for storing inaccesible variables
pidDir="/tmp/$USER/$programName"
mkdir -p "$pidDir"/clean

pre(){
	# kill secret services: if someone unlocks my screen, at least they won't have my unencrypted passwords
	passwords -k -K -q 2>/dev/null &

	dunstctl set-paused true
	find "$pidDir" -type f -print0 | xargs -0 rm 2>/dev/null
}
post(){
	dunstctl set-paused false
	kill $(cat "$pidDir/clean"/*) 2>/dev/null
}

# simple fallback always runs in case the lock cover fails
fallback(){
	sleep 3
	# external variables used here have to be imported from $pidDIR
	for f in "$pidDir"/* ; do
		eval "$(basename "$f")='$(cat "$f")'"
	done
	waitpid $coverPID; (
		notify-send -u critical "Lock screen" "Cover failed. Used fallback" &
		kill $funcPID
		kill $lockPID
		lock
	)

} 2>/dev/null

# set up visualizer
visualizer()(
	terminal=alacritty

	lock -b none & lockPID=$!
	echo $lockPID > "$pidDir/lockPID"

	# pause all non-server programs accessing the fifo
	fifoFile="/tmp/mpd.fifo"
	# pause the shells attached to visualizers (if any) to prevent shitassery
	blackParents=$(chsh -l | while read sh; do basename "$sh"; done)
	# protect these programs accessing the fifo from being paused
	whiteChildren="mpd safe_fifo"

	# create and kill pidList
	for pid in $(lsof "$fifoFile" | sed '1d' | sed 's/\S*\s*//' | cut -d' ' -f1); do
	# for pid in $(sleep 100 | sed '1d' | sed 's/\S*\s*//' | cut -d' ' -f1); do
		pidName="$(ps -cp $pid -o comm="" | sed 's/^\s*//')"
		for n in $whiteChildren; do
			if [ "$n" = "$pidName" ]; then
				protect=true
				break
			else
				protect=false
			fi
		done
		$protect || pidList="$pidList $pid"
		ppid="$(ps -cp $pid -o ppid="" | sed 's/^\s*//')"
		ppidName="$(ps -cp $ppid -o comm="" | sed 's/^\s*//')"
		for n in $blackParents; do
			if [ "$ppidName" = "$n" ]; then 
				pidList="$pidList $ppid"
			fi
		done
	done
	kill -s STOP $pidList 2>/dev/null

	# kitty -o background="#000000" -o background_opacity=1 -o font_size=10 --start-as fullscreen vis & termPID=$!
	alacritty -o 'colors.primary.background="#000000"' -o 'window.opacity=1' -o 'window.startup_mode=Fullscreen' -e vis & coverPID=$!
	echo $coverPID > "$pidDir/coverPID"

	wait "$lockPID"
	{
		kill "$fallbackPID"
		kill "$coverPID"
		kill -s CONT $pidList
	} &
)

xscreensaver()(
	eval 'set -- '$(getopt -o 't:c' -- "$@")
	t=1m
	unset exe
	while true; do
		case "$1" in
			-t)
				t=$2
				shift 2
				;;
			-c)
				cycle=true
				shift
				;;
			--)
				shift
				break
				;;
		esac
	done
	[ $1 ] && exe=/usr/lib/xscreensaver/$1
	lock -b none & lockPID=$!
	echo $lockPID > "$pidDir/lockPID"
	# find all Xephyr-labelled WIDs to compare them later, because Xephyr doesn't attach pids to their windows
	xdotool search --name '^Xephyr' | sort > "$pidDir/widList"
	Xephyr :5 -fullscreen -no-host-grab -glamor 2>/dev/null & coverPID=$!
	echo $coverPID > "$pidDir/coverPID"
	while [ ! "$coverWID" ]; do
		coverWID=$(xdotool search --name '^Xephyr' | sort | comm --nocheck-order -13 "$pidDir/widList" /dev/stdin)
	done
	xdotool windowactivate $coverWID; xdotool windowstate --add FULLSCREEN $coverWID
	(
		sleep 1
		# export DISPLAY=:5
		size=$(xdotool getdisplaygeometry)
		while true; do
			unset exePID
			until [ $exe ]; do
				exe=$(find /usr/lib/xscreensaver -maxdepth 1 -type f | grep -v "xscreensaver/xscreensaver" | shuf -n1)
				file --mime-type "$exe" | grep -F executable >/dev/null || unset exe
			done
			echo displaying "'$exe'" >&2
			$exe & exePID=$!
			echo $exePID > "$pidDir/clean/exe"
			unset wid exe
			until [ $wid ]; do # xdotool's --sync is SLOW
				wid=$(xdotool search --pid $exePID)
			done
			xdotool windowsize "$wid" $size &
			xdotool windowstate --add FULLSCREEN "$wid"
			[ ! "$cycle" ] && wait
			sleep $t
			kill "$exePID"
		done
	) & coverPID="$coverPID $!"

	wait "$lockPID"
	{
		kill "$fallbackPID"
		kill $coverPID
	} &
)

# main
pre
fallback & fallbackPID=$!
[ "$1" = "-e" ] && exe=$2 && shift 2 || exe=visualizer
$exe "$@" & echo $! > "$pidDir/funcPID"
wait
post
