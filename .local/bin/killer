#!/bin/sh
# todo: signal handling

# kill everything, as gracefully and as correctly as possible
# usage:
# killer ["nofork"] [OPTION]... [PID]...
# "nofork" prevents forking
# PID will not be killed
#
# options:
# -c: send CONT signal after TERM
# -l: kill user login shells using HUP
# -p: also kill parent process, only applicable with nofork
# -t <t>: timeout time. default is 15s
# -u <user>: set user processes to kill. generally only useful as root
#
# examples:
# `killer` without root will fork, and kill all processes owned by $USER, except login shells.
# 'killer -l` will kill login shells after killing everything else.
# `killer` as root kills every process owned by every user (including root) except their login shells.
# `killer nofork` will prevent forking. this can cause the script to kill a distant parent that it needs to survive, like Xorg hosting the terminal that runs `killer`.

if [ "$1" = "nofork" ]; then shift
else
	exec setsid -f "$0" nofork "$@"
fi

timeout=15000
[ "$(whoami)" = root ] && root=true || user=$USER
while true; do
	[ "$1" = "-c" ] && { continue=true; shift; continue; }
	[ "$1" = "-l" ] && { killlogin=true; shift; continue; }
	[ "$1" = "-p" ] && { killppid=true; shift; continue; }
	[ "$1" = "-t" ] && { timeout=$(($2 * 1000)); shift 2; continue; }
	[ "$1" = "-u" ] && { user=$2; shift 2; continue; }
	break
done

sedscript=$(mktemp)
trap 'rm "$sedscript"; exit' INT TERM

addpid(){
	printf '/^%s$/d\n' "$@" >> "$sedscript"
}

[ "$killppid" ] || ppid=$(cut -d' ' -f4 < "/proc/$$/stat")
if [ "$user" ]; then
	loginpids=$(pgrep -P "$(who -u | awk '{if ($1 == "'"$user"'") print $6}' | tr '\n' , | head -c -1)")
else
	loginpids=$(pgrep -P "$(who -u | awk '{print $6}' | tr '\n' , | head -c -1)")
	fi

addpid 1 "$@" $ppid $loginpids

if [ "$user" ]; then
	alias getpids='pgrep -u "$user"'
else
	alias getpids='pgrep -v -P2' # all non-kernel pids
fi

pidxarger(){
	addpid $(cut -d' ' -f4 </proc/self/stat) # like $$ but not main process
	tmp=$(getpids)
	echo "$tmp" | sed -f "$sedscript" | head -c -1 | xargs -d'\n' "$@"
}

# kill as much as possible to reduce process count
pidxarger ps -o pid= -p >/dev/null 2>&1 && {
	echo 'killing everything...'
	pidxarger kill -s TERM 2>/dev/null
	[ "$continue" ] && pidxarger kill -s CONT 2>/dev/null
	sleep 1
	list=$(pidxarger ps -p 2>/dev/null) && {
		echo 'remaining processes:'
		echo "$list"
		echo
		
		# of remaining/newly-spawned processes, give them one last chance
		if env kill --version | grep -qF 'pidfd'; then
			echo 'killing leftovers after timeout...'
			echo "timeout time: $(($timeout / 1000))s"
			pidxarger -P0 -L1 kill --timeout "$timeout" KILL -s TERM 2>/dev/null &
			time=$(date +%s.%N)
			wait
			echo "took $(echo "$(date +%s.%N) - $time" | bc)s"
		else
			echo 'kill util not installed with pidfd support. sleeping...'
			sleep 7 &
			wait
		fi
		
		list=$(pidxarger ps -p 2>/dev/null) && {
			# if something is somehow still up
			echo 'remaining processes:'
			echo "$list"
			echo
			echo 'killing anything left...'
			pidxarger kill -s KILL 2>/dev/null
		}
	}
	[ "$killlogin" ] || echo 'done'
}
[ "$killlogin" ] && {
	echo "killing logout shells..."
	kill -s TERM $loginpids
	kill -s HUP $loginpids
}
rm "$sedscript"
