#!/bin/sh
# todo: better arguments, better command searching

# checks
command -v rsync >/dev/null 2>&1 || { echo "needs rsync bud. exiting"; exit 1; }

[ $# -lt 2 ] && echo 'need at least 2 arguments. exiting' && exit 1

for arg; do [ -z "$arg" ] && echo 'an argument was empty. exiting' && exit 1; done

# options:
# -D [-e]: launch a daemon, -e to exit on process death (doesn't work with pid)
# -C: clean up files on daemon exit, or just clean files if no daemon. does NOT sync first.
# -t: set check time
# -u: set online/generic wait time between syncs
# -d: set offline wait time between syncs. set to 0 to disable daemon when offline
# -s: <dir>: sync files somewhere else instead of /dev/shm
# -c: check if dir is unpacked before syncing without daemon
# -f: match for full command line for command search
# -a: automatically sync once before launching daemon
# 1: unique name
# 2: copied directory
# [3]: command or executable file for monitored daemoning, can use pid instead with -p <pid>

# defaults
timeCheck=5
tmpDir=/dev/shm/$USER/$(basename "$0")

# opts
while true; do
	[ "$1" = "--" ] && { shift; break; }
	[ "$1" = "-c" ] && { check=true; shift; continue; }
	[ "$1" = "-s" ] && { tmpDir=$2; shift 2; continue; }
	[ "$1" = "-u" ] && { timeUp=$2; shift 2; continue; }
	[ "$1" = "-d" ] && { timeDown=$2; shift 2; continue; }
	[ "$1" = "-t" ] && { timeCheck=$2; shift 2; continue; }
	[ "$1" = "-D" ] && {
		daemon=true && shift &&
			[ "$1" = "-e" ] && { exitDown=true; exitDownWait=true; exitCheck=true; shift; }
		continue
	}
	[ "$1" = "-C" ] && { clean=true; shift; continue; }
	[ "$1" = "-f" ] && { full=true shift; continue; }
	[ "$1" = "-a" ] && { auto=true; shift; continue; }
	break
done;

# defaults
[ "$timeUp" ] || timeUp=30m
[ "$timeDown" ] || timeDown=$timeUp

# args
name=$1
linkDir=$(realpath -s "$2")
[ -h "$linkDir" ] || [ -d "$linkDir" ] || {
	echo "'$linkDir' is not a dir. exiting" >&2
	exit 1
}

if [ "$3" = "--" ]; then
	command=$4
elif [ "$3" = "-p" ]; then
	pid=$4
	[ "$pid" -gt 0 ] || {
		echo "'$pid' not a proper PID. exiting"
		exit 1
	}
	[ -d "/proc/$pid" ] || {
		echo "pid '$pid' not running. exiting"
		exit 1
	}
else
	command=$3
fi
[ "$command" ] && {
	command -v "$command" || {
		echo "note: '$command' not found in PATH"
	}
}
if [ "$full" ]; then
	alias pgrep='pgrep -f';
elif [ "$command" != "$(echo "$command" | head -c 15)" ]; then
	echo "'$command' longer than 15 chars, use '-f' flag. exiting"
	exit 1
fi

staticDir="${linkDir}-static"
tmpDir="$tmpDir/$name"
memDir="$tmpDir/data"
unpackFile="$tmpDir/unpacked"
lockFile="$tmpDir/lock"

cleanup(){
	path=$(readlink "$linkDir") || {
		echo "'$linkDir' not a symlink, not cleaning"
		return 1
	}
	if [ "$path" = "$tmpDir/data" ]; then
		echo cleaning
		rm -v -- "$linkDir"
		mv -Tfv -- "$staticDir" "$linkDir"
		echo "removing '$tmpDir'"
		rm -rf -- "$tmpDir"
	else
		echo "'$linkDir' not symlinked to '$tmpDir/data', not cleaning"
	fi
}

[ "$clean" ] && [ ! "$daemon" ] && {
	cleanup
	exit
}

exiter(){
	echo 'exiting properly'
	[ "$daemon" ] && {
		[ "$daemonPID" ] && killdaemon
	}
	[ -e "$lockFile" ] && rm -v "$lockFile"
	exit
}
trap 'sync; exit' INT TERM
trap exiter EXIT
# on normal exit, whether it syncs is up to the program. on kill, it always syncs.

sync(){
	[ "$1" = "auto" ] && {
		if [ -e "$unpackFile" ]; then
			sync
		else
			sync disk
		fi
		return
	}
	date
	printf 'syncing '
	if [ "$1" = "disk" ]; then
		echo 'from disk to ram'
		mkdir -vp "$tmpDir"

		# make memDir
		[ -r "$memDir" ] || {
			mkdir -m0700 "$memDir"
		}
		# link memDir to linkDir
		[ "$(readlink "$linkDir")" = "$memDir" ] || {
			mv -vT "$linkDir" "$staticDir"
			ln -vsT "$memDir" "$linkDir"
		}

		rsync -aHAWXv "$staticDir/" "$linkDir" &&
			touch "$unpackFile" || {
			echo "epic fail" && exit 1
		}
	else
		echo 'from ram to disk'
		[ -e "$unpackFile" ] || {
			echo "cannot sync, nothing in '$tmpDir'. exiting"
			exit 1
		}
		[ -e "$lockFile" ] && {
			echo 'lock in place, waiting for removal...'
			while [ -e "$lockFile" ]; do sleep 1; done
		}
		touch "$lockFile"
		rsync -aHAWXv --delete "$linkDir/" "$staticDir" || {
			echo 'sync error! exiting'
					rm -v "$lockFile"
					exit 1
				}
				rm "$lockFile"
	fi
	echo
}

if [ ! "$daemon" ]; then
	if [ "$check" ]; then
		sync
	else
		sync auto
	fi
else
	[ "$auto" ] && sync auto
	daemon(){
		if [ "$daemonPID" ]; then # daemon is running
			# reset sleep
			[ "$2" = "reset" ] && {
				killdaemon
				sync
				daemon "$@"
			}
		else # launch daemon
			{
				trap 'kill -- $watchPID; kill -- $loopPID; exit' TERM INT
				{
					trap 'exit' INT TERM
					trap 'kill -- $!' EXIT
					while true; do
						sleep "$1" &
						wait
						sync || exit 1
					done
				} & loopPID=$!
				{
					{
						waitpid $$
						echo 'daemon: parent was murdered, exiting'
						kill $loopPID
					} & pid=$!
					{
						waitpid $loopPID
						echo 'daemon was killed, exiting'
						kill $$
					} & pid="$pid $!"
					trap 'kill $pid' INT TERM
					wait
				} & watchPID=$!
				while true; do wait && break; done
			} & daemonPID=$!
		fi
	}
	killdaemon(){
		[ "$daemonPID" ] && {
			kill $daemonPID
			unset daemonPID
		}
	}

	if [ "$command" ]; then
		# track by command name
		echo "watching '$command' command"
		while true; do
			if pgrep -x "$command" >/dev/null; then
				[ "$down" ] && echo "'$command' is up"
				wasUp=true
				[ "$exitDownWait" ] && exitCheck=true
				daemon "$timeUp" reset
				unset down
				pidwait -x "$command" &
				wait $!

			else
				[ "$down" ] || echo "'$command' is down"
				if [ "$exitDown" ]; then # exit
					if [ "$exitCheck" ]; then # wait
						echo "'$command' not running, waiting once"
						unset exitCheck
					else
						echo "'$command' not running, exiting."
						killdaemon
						[ "$wasUp" ] && sync
						exit
					fi

				elif [ "$timeDown" = 0 ]; then
					[ "$down" ] || {
						killdaemon
						sync
					}
				else
					daemon "$timeDown" "$([ "$down" ] || echo reset)"
				fi
				down=true
				sleep "$timeCheck" &
				wait $!
			fi
		done
	elif [ "$pid" ]; then
		# track via waitpid
		daemon "$timeUp"
		waitpid "$pid" &
		wait $!
		killdaemon
		sync
	else
		# just run it
		echo 'daemon will run until it is killed'
		daemon "$timeUp"
		wait
	fi
fi
