#!/bin/sh
set -e

command -v rsync >/dev/null 2>&1 || { echo "needs rsync bud. exiting"; exit 1; }

[ $# -lt 2 ] && echo 'need at least 2 arguments. exiting' && exit 1

for arg; do [ -z "$arg" ] && echo 'an argument was empty. exiting' && exit 1; done

# options:
# -d [-e]: launch a daemon, -e to exit on process death (doesn't work with pid)
# -c: clean up files on daemon exit, or just clean files if no daemon. does NOT sync first.
# -t: set sync wait time
# -s <dir>: sync files somewhere else instead of /dev/shm
# 1: unique name
# 2: copied directory
# [3]: command or executable file for monitored daemoning, can use pid instead with -p <pid>

time=30m
tmpDir=/dev/shm/$USER/$(basename "$0")

while true; do
	[ "$1" = "--" ] && shift && break
	[ "$1" = "-s" ] && tmpDir=$2 && shift 2 && continue
	[ "$1" = "-t" ] && time=$2 && shift 2 && continue
	[ "$1" = "-d" ] && {
		daemon=true && shift &&
			[ "$1" = "-e" ] && exitDown=true && exitDownWait=true && shift
		continue
	}
	[ "$1" = "-c" ] && clean=true && shift && continue
	break
done;

name=$1
linkDir=$2
[ -h "$linkDir" ] || [ -d "$linkDir" ] || {
	echo "'$linkDir' is not a dir" >&2
	exit 1
}

tmpDir="$tmpDir/$name"
mkdir -p "$tmpDir"

if [ "$3" = "-p" ]; then
	pid=$4
	[ "$pid" ] || exit 1
else
	bin=$(basename "$(command -v "$1")")
	[ -z "$bin" ] && unset bin
fi

staticDir="${linkDir}-static"

memDir="$tmpDir/data"
unpackFile="$tmpDir/unpacked"
lockFile="$tmpDir/lock"

cleanup(){
	path=$(readlink "$linkDir") || {
		echo "'$linkDir' not a symlink, not cleaning"
		return 1
	}
	if [ "$path" = "$tmpDir/data" ]; then
		echo cleaning
		rm -v -- "$linkDir"
		mv -Tfv -- "$staticDir" "$linkDir"
		echo "removing '$tmpDir"
		rm -rf -- "$tmpDir"
	else
		echo "'$linkDir' not symlinked to '$tmpDir/data', not cleaning"
	fi
}

[ "$clean" ] && {
	if [ "$daemon" ]; then
		trap 'cleanup' EXIT
	else
		cleanup
		exit
	fi
}

startup(){
	# make mem dir
	[ -r "$memDir" ] || {
		mkdir -m0700 "$memDir"
	}
	# link mem dir to linkDir
	[ "$(readlink "$linkDir")" = "$memDir" ] || {
		mv -vT "$linkDir" "$staticDir"
		ln -vsT "$memDir" "$linkDir"
	}
}
startup

sync(){
	# notify-send syncing
	printf 'syncing '
	if [ -e "$unpackFile" ]; then
		echo 'from ram to disk'
		[ -e "$lockFile" ] && {
			echo 'lock in place, waiting for removal...'
			while [ -e "$lockFile" ]; do sleep 1; done
		}
		touch "$lockFile"
		rsync -aHAWXv --delete "$linkDir/" "$staticDir"
		rm "$lockFile"
	else
		echo 'from disk to ram'
		rsync -aHAWXv "$staticDir/" "$linkDir" &&
			touch "$unpackFile" || {
				echo "epic fail" && exit 1
			}
	fi
}

if [ ! "$daemon" ]; then
	sync
else
	daemon(){
		{
			trap 'kill -- $!' TERM INT
			while true; do
				sleep "$time" &
				wait
				sync
			done
		} & syncerPID=$!
		"$@" # waiter
		echo process was killed
		kill $syncerPID
		wait
		sync
	}

	if [ "$bin" ]; then
		while true; do
			if pidof "$bin" >/dev/null; then
				echo bin is up
				unset syncerPID
				unset exitDownWait
				daemon pidwait -x "$bin"
			else
				echo bin is down
				if [ "$exitDown" ]; then
					[ "$exitDownWait" ] || break
					echo waiting once
					unset exitDownWait
				fi
				sleep 5
			fi
		done
	elif [ "$pid" ]; then
		daemon waitpid "$pid"
	else
		echo "daemon will keep running until it's killed."
		trap 'kill -- $!' TERM INT
		while true; do
			sleep "$time" &
			wait
			sync
		done
	fi
fi
