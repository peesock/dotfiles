#!/bin/sh
# todo: better arguments

# checks
command -v rsync >/dev/null 2>&1 || { echo "needs rsync bud. exiting"; exit 1; }

[ $# -lt 2 ] && echo 'need at least 2 arguments. exiting' && exit 1

for arg; do [ -z "$arg" ] && echo 'an argument was empty. exiting' && exit 1; done

# options:
# -D [-e]: launch a daemon, -e to exit on process death (doesn't work with pid)
# -C: clean up files on daemon exit, or just clean files if no daemon. does NOT sync first.
# -t: set check time
# -u: set online/generic wait time between syncs
# -d: set offline wait time between syncs. set to 0 to disable daemon when offline
# -s: <dir>: sync files somewhere else instead of /dev/shm
# -c: return 0 if dir is unpacked
# 1: unique name
# 2: copied directory
# [3]: command or executable file for monitored daemoning, can use pid instead with -p <pid>

# defaults
timeCheck=5
tmpDir=/dev/shm/$USER/$(basename "$0")

# opts
while true; do
	[ "$1" = "--" ] && { shift; break; }
	[ "$1" = "-c" ] && { check=true; shift; continue; }
	[ "$1" = "-s" ] && { tmpDir=$2; shift 2; continue; }
	[ "$1" = "-u" ] && { timeUp=$2; shift 2; continue; }
	[ "$1" = "-d" ] && { timeDown=$2; shift 2; continue; }
	[ "$1" = "-t" ] && { timeCheck=$2; shift 2; continue; }
	[ "$1" = "-D" ] && {
		daemon=true && shift &&
			[ "$1" = "-e" ] && { exitDown=true; exitDownWait=true; exitCheck=true; shift; }
		continue
	}
	[ "$1" = "-C" ] && { clean=true; shift; continue; }
	break
done;

# defaults
[ "$timeUp" ] || timeUp=30m
[ "$timeDown" ] || timeDown=$timeUp

# args
name=$1
linkDir=$2
[ -h "$linkDir" ] || [ -d "$linkDir" ] || {
	echo "'$linkDir' is not a dir. exiting" >&2
	exit 1
}

if [ "$3" = "--" ]; then
	bin=$4
elif [ "$3" = "-p" ]; then
	pid=$4
	[ "$pid" -gt 0 ] || {
		echo "'$pid' not a proper PID. exiting"
		exit 1
	}
	[ -d "/proc/$pid" ] || {
		echo "pid '$pid' not running. exiting"
		exit 1
	}
else
	bin=$3
fi
[ "$bin" ] && {
	bin=$(basename "$(command -v "$bin")")
	[ -z "$bin" ] && {
		echo 'command not found. exiting'
		exit 1
	}
}

staticDir="${linkDir}-static"

tmpDir="$tmpDir/$name"
memDir="$tmpDir/data"
unpackFile="$tmpDir/unpacked"
lockFile="$tmpDir/lock"

[ "$check" ] && {
	[ -e "$unpackFile" ] && exit 0
	exit 1
}

cleanup(){
	path=$(readlink "$linkDir") || {
		echo "'$linkDir' not a symlink, not cleaning"
		return 1
	}
	if [ "$path" = "$tmpDir/data" ]; then
		echo cleaning
		rm -v -- "$linkDir"
		mv -Tfv -- "$staticDir" "$linkDir"
		echo "removing '$tmpDir"
		rm -rf -- "$tmpDir"
	else
		echo "'$linkDir' not symlinked to '$tmpDir/data', not cleaning"
	fi
}

[ "$clean" ] && [ ! "$daemon" ] && {
	cleanup
	exit
}

exiter(){
	[ "$daemon" ] && {
		[ "$daemonPID" ] && killdaemon
	}
	exit
}
trap 'sync; exit' INT TERM
trap exiter EXIT

# startup
mkdir -p "$tmpDir"

[ -e "$lockFile" ] && rm -v "$lockFile"

# make mem dir
[ -r "$memDir" ] || {
	mkdir -m0700 "$memDir"
}
# link mem dir to linkDir
[ "$(readlink "$linkDir")" = "$memDir" ] || {
	mv -vT "$linkDir" "$staticDir"
	ln -vsT "$memDir" "$linkDir"
}

sync(){
	# notify-send syncing
	printf 'syncing '
	if [ -e "$unpackFile" ]; then
		echo 'from ram to disk'
		[ -e "$lockFile" ] && {
			echo 'lock in place, waiting for removal...'
			while [ -e "$lockFile" ]; do sleep 1; done
		}
		touch "$lockFile"
		rsync -aHAWXv --delete "$linkDir/" "$staticDir" || {
			echo 'sync error! exiting'
			rm -v "$lockFile"
			exit 1
		}
		rm "$lockFile"
	else
		echo 'from disk to ram'
		rsync -aHAWXv "$staticDir/" "$linkDir" &&
			touch "$unpackFile" || {
				echo "epic fail" && exit 1
			}
	fi
}

if [ ! "$daemon" ]; then
	sync
else
	daemon(){
		if [ "$daemonPID" ]; then # daemon is running
			# reset sleep
			[ "$2" = "reset" ] && {
				killdaemon
				sync
				daemon "$@"
			}
		else # launch daemon
			{
				trap 'kill -- $watchPID; kill -- $loopPID; exit' TERM INT
				{
					trap 'exit' INT TERM
					trap 'kill -- $!' EXIT
					while true; do
						sleep "$1" &
						wait
						sync
					done
				} & loopPID=$!
				{
					{
						waitpid $$
						echo 'daemon: parent was murdered, exiting'
						kill $loopPID
					} & pid=$!
					{
						waitpid $loopPID
						echo 'daemon was killed, exiting'
						kill $$
					} & pid="$pid $!"
					trap 'kill $pid' INT TERM
					wait
				} & watchPID=$!
				while true; do wait && break; done
			} & daemonPID=$!
		fi
	}
	killdaemon(){
		[ "$daemonPID" ] && {
			kill $daemonPID
			unset daemonPID
		}
	}

	if [ "$bin" ]; then
		# track by command name
		echo "watching '$bin' command"
		while true; do
			if pgrep -x "$bin" >/dev/null; then
				[ "$down" ] && echo "'$bin' is up"
				[ "$exitDownWait" ] && exitCheck=true
				daemon "$timeUp" reset
				unset down
				pidwait -x "$bin" &
				wait $!

			else
				[ "$down" ] || echo "'$bin' is down"
				if [ "$exitDown" ]; then # exit
					if [ "$exitCheck" ]; then # wait
						echo "'$bin' not running, waiting once"
						unset exitCheck
					else
						echo "'$bin' not running, exiting."
						killdaemon
						exit
					fi

				elif [ "$timeDown" = 0 ]; then
					[ "$down" ] || {
						killdaemon
						sync
					}
				else
					daemon "$timeDown" "$([ "$down" ] || echo reset)"
				fi
				down=true
				sleep "$timeCheck" &
				wait $!
			fi
		done
	elif [ "$pid" ]; then
		# track via waitpid
		daemon "$timeUp"
		waitpid "$pid" &
		wait $!
		killdaemon
		sync
	else
		# just run it
		echo 'daemon will run until it is killed'
		daemon "$timeUp"
		wait
	fi
fi
